                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 3.5.0 #9253 (Mar 24 2016) (Linux)
                                      4 ; This file was generated Mon Mar 12 12:44:09 2018
                                      5 ;--------------------------------------------------------
                                      6 	.module uart
                                      7 	.optsdcc -mstm8
                                      8 	
                                      9 ;--------------------------------------------------------
                                     10 ; Public variables in this module
                                     11 ;--------------------------------------------------------
                                     12 	.globl _uart_read_to_buf
                                     13 	.globl _uart_write_from_buf
                                     14 	.globl _fixed_round
                                     15 	.globl _digits_buf
                                     16 	.globl _read_newline
                                     17 	.globl _uart_read_len
                                     18 	.globl _uart_read_buf
                                     19 	.globl _uart_write_len
                                     20 	.globl _uart_write_start
                                     21 	.globl _uart_write_buf
                                     22 	.globl _uart_init
                                     23 	.globl _uart_write_ch
                                     24 	.globl _uart_write_str
                                     25 	.globl _uart_write_int
                                     26 	.globl _uart_write_int32
                                     27 	.globl _uart_write_milliamp
                                     28 	.globl _uart_write_millivolt
                                     29 	.globl _uart_write_fixed_point
                                     30 	.globl _uart_drive
                                     31 	.globl _uart_flush_writes
                                     32 ;--------------------------------------------------------
                                     33 ; ram data
                                     34 ;--------------------------------------------------------
                                     35 	.area DATA
      000000                         36 _uart_write_buf::
      000000                         37 	.ds 255
      0000FF                         38 _uart_write_start::
      0000FF                         39 	.ds 1
      000100                         40 _uart_write_len::
      000100                         41 	.ds 1
      000101                         42 _uart_read_buf::
      000101                         43 	.ds 64
      000141                         44 _uart_read_len::
      000141                         45 	.ds 1
      000142                         46 _read_newline::
      000142                         47 	.ds 1
      000143                         48 _digits_buf::
      000143                         49 	.ds 12
                                     50 ;--------------------------------------------------------
                                     51 ; ram data
                                     52 ;--------------------------------------------------------
                                     53 	.area INITIALIZED
                                     54 ;--------------------------------------------------------
                                     55 ; absolute external ram data
                                     56 ;--------------------------------------------------------
                                     57 	.area DABS (ABS)
                                     58 ;--------------------------------------------------------
                                     59 ; global & static initialisations
                                     60 ;--------------------------------------------------------
                                     61 	.area HOME
                                     62 	.area GSINIT
                                     63 	.area GSFINAL
                                     64 	.area GSINIT
                                     65 ;--------------------------------------------------------
                                     66 ; Home
                                     67 ;--------------------------------------------------------
                                     68 	.area HOME
                                     69 	.area HOME
                                     70 ;--------------------------------------------------------
                                     71 ; code
                                     72 ;--------------------------------------------------------
                                     73 	.area CODE
                                     74 ;	uart.c: 31: void uart_init()
                                     75 ;	-----------------------------------------
                                     76 ;	 function uart_init
                                     77 ;	-----------------------------------------
      000000                         78 _uart_init:
                                     79 ;	uart.c: 33: USART1_CR1 = 0; // 8 bits, no parity
      000000 35 00 52 34      [ 1]   80 	mov	0x5234+0, #0x00
                                     81 ;	uart.c: 34: USART1_CR2 = 0;
      000004 35 00 52 35      [ 1]   82 	mov	0x5235+0, #0x00
                                     83 ;	uart.c: 35: USART1_CR3 = 0;
      000008 35 00 52 36      [ 1]   84 	mov	0x5236+0, #0x00
                                     85 ;	uart.c: 37: USART1_BRR2 = 0x1;
      00000C 35 01 52 33      [ 1]   86 	mov	0x5233+0, #0x01
                                     87 ;	uart.c: 38: USART1_BRR1 = 0x1A; // 38400 baud, order important between BRRs, BRR1 must be last
      000010 35 1A 52 32      [ 1]   88 	mov	0x5232+0, #0x1a
                                     89 ;	uart.c: 40: USART1_CR2 = USART_CR2_TEN | USART_CR2_REN; // Allow TX & RX
      000014 35 0C 52 35      [ 1]   90 	mov	0x5235+0, #0x0c
                                     91 ;	uart.c: 42: uart_write_len = 0;
      000018 72 5Fu01u00      [ 1]   92 	clr	_uart_write_len+0
                                     93 ;	uart.c: 43: uart_write_start = 0;
      00001C 72 5Fu00uFF      [ 1]   94 	clr	_uart_write_start+0
                                     95 ;	uart.c: 44: uart_read_len = 0;
      000020 72 5Fu01u41      [ 1]   96 	clr	_uart_read_len+0
                                     97 ;	uart.c: 45: read_newline = 0;
      000024 72 5Fu01u42      [ 1]   98 	clr	_read_newline+0
      000028 81               [ 4]   99 	ret
                                    100 ;	uart.c: 53: void uart_write_ch(const char ch)
                                    101 ;	-----------------------------------------
                                    102 ;	 function uart_write_ch
                                    103 ;	-----------------------------------------
      000029                        104 _uart_write_ch:
      000029 89               [ 2]  105 	pushw	x
                                    106 ;	uart.c: 55: if (uart_write_len < sizeof(uart_write_buf))
      00002A C6u01u00         [ 1]  107 	ld	a, _uart_write_len+0
      00002D A1 FF            [ 1]  108 	cp	a, #0xff
      00002F 24 15            [ 1]  109 	jrnc	00103$
                                    110 ;	uart.c: 56: uart_write_buf[uart_write_len++] = ch;
      000031 AEr00r00         [ 2]  111 	ldw	x, #_uart_write_buf+0
      000034 1F 01            [ 2]  112 	ldw	(0x01, sp), x
      000036 C6u01u00         [ 1]  113 	ld	a, _uart_write_len+0
      000039 97               [ 1]  114 	ld	xl, a
      00003A 72 5Cu01u00      [ 1]  115 	inc	_uart_write_len+0
      00003E 4F               [ 1]  116 	clr	a
      00003F 95               [ 1]  117 	ld	xh, a
      000040 72 FB 01         [ 2]  118 	addw	x, (0x01, sp)
      000043 7B 05            [ 1]  119 	ld	a, (0x05, sp)
      000045 F7               [ 1]  120 	ld	(x), a
      000046                        121 00103$:
      000046 85               [ 2]  122 	popw	x
      000047 81               [ 4]  123 	ret
                                    124 ;	uart.c: 59: void uart_write_str(const char *str)
                                    125 ;	-----------------------------------------
                                    126 ;	 function uart_write_str
                                    127 ;	-----------------------------------------
      000048                        128 _uart_write_str:
      000048 52 05            [ 2]  129 	sub	sp, #5
                                    130 ;	uart.c: 64: if (uart_write_start > 0) {
      00004A 72 5Du00uFF      [ 1]  131 	tnz	_uart_write_start+0
      00004E 27 2C            [ 1]  132 	jreq	00119$
                                    133 ;	uart.c: 65: for (i = 0; i < uart_write_len; i++) {
      000050 AEr00r00         [ 2]  134 	ldw	x, #_uart_write_buf+0
      000053 1F 04            [ 2]  135 	ldw	(0x04, sp), x
      000055 0F 01            [ 1]  136 	clr	(0x01, sp)
      000057                        137 00106$:
      000057 7B 01            [ 1]  138 	ld	a, (0x01, sp)
      000059 C1u01u00         [ 1]  139 	cp	a, _uart_write_len+0
      00005C 24 1A            [ 1]  140 	jrnc	00101$
                                    141 ;	uart.c: 66: uart_write_buf[i] = uart_write_buf[i+uart_write_start];
      00005E 90 5F            [ 1]  142 	clrw	y
      000060 7B 01            [ 1]  143 	ld	a, (0x01, sp)
      000062 90 97            [ 1]  144 	ld	yl, a
      000064 72 F9 04         [ 2]  145 	addw	y, (0x04, sp)
      000067 7B 01            [ 1]  146 	ld	a, (0x01, sp)
      000069 CBu00uFF         [ 1]  147 	add	a, _uart_write_start+0
      00006C 5F               [ 1]  148 	clrw	x
      00006D 97               [ 1]  149 	ld	xl, a
      00006E 72 FB 04         [ 2]  150 	addw	x, (0x04, sp)
      000071 F6               [ 1]  151 	ld	a, (x)
      000072 90 F7            [ 1]  152 	ld	(y), a
                                    153 ;	uart.c: 65: for (i = 0; i < uart_write_len; i++) {
      000074 0C 01            [ 1]  154 	inc	(0x01, sp)
      000076 20 DF            [ 2]  155 	jra	00106$
      000078                        156 00101$:
                                    157 ;	uart.c: 68: uart_write_start = 0;
      000078 72 5Fu00uFF      [ 1]  158 	clr	_uart_write_start+0
                                    159 ;	uart.c: 71: for(i = 0; str[i] != 0 && uart_write_len < sizeof(uart_write_buf); i++) {
      00007C                        160 00119$:
      00007C AEr00r00         [ 2]  161 	ldw	x, #_uart_write_buf+0
      00007F 1F 02            [ 2]  162 	ldw	(0x02, sp), x
      000081 0F 01            [ 1]  163 	clr	(0x01, sp)
      000083                        164 00110$:
      000083 5F               [ 1]  165 	clrw	x
      000084 7B 01            [ 1]  166 	ld	a, (0x01, sp)
      000086 97               [ 1]  167 	ld	xl, a
      000087 72 FB 08         [ 2]  168 	addw	x, (0x08, sp)
      00008A F6               [ 1]  169 	ld	a, (x)
      00008B 90 95            [ 1]  170 	ld	yh, a
      00008D A1 00            [ 1]  171 	cp	a, #0x00
      00008F 27 1A            [ 1]  172 	jreq	00112$
      000091 C6u01u00         [ 1]  173 	ld	a, _uart_write_len+0
      000094 A1 FF            [ 1]  174 	cp	a, #0xff
      000096 24 13            [ 1]  175 	jrnc	00112$
                                    176 ;	uart.c: 72: uart_write_buf[uart_write_len] = str[i];
      000098 5F               [ 1]  177 	clrw	x
      000099 C6u01u00         [ 1]  178 	ld	a, _uart_write_len+0
      00009C 97               [ 1]  179 	ld	xl, a
      00009D 72 FB 02         [ 2]  180 	addw	x, (0x02, sp)
      0000A0 90 9E            [ 1]  181 	ld	a, yh
      0000A2 F7               [ 1]  182 	ld	(x), a
                                    183 ;	uart.c: 73: uart_write_len++;
      0000A3 72 5Cu01u00      [ 1]  184 	inc	_uart_write_len+0
                                    185 ;	uart.c: 71: for(i = 0; str[i] != 0 && uart_write_len < sizeof(uart_write_buf); i++) {
      0000A7 0C 01            [ 1]  186 	inc	(0x01, sp)
      0000A9 20 D8            [ 2]  187 	jra	00110$
      0000AB                        188 00112$:
      0000AB 5B 05            [ 2]  189 	addw	sp, #5
      0000AD 81               [ 4]  190 	ret
                                    191 ;	uart.c: 78: static uint8_t int_to_digits(uint16_t val)
                                    192 ;	-----------------------------------------
                                    193 ;	 function int_to_digits
                                    194 ;	-----------------------------------------
      0000AE                        195 _int_to_digits:
      0000AE 52 05            [ 2]  196 	sub	sp, #5
                                    197 ;	uart.c: 81: uint8_t num_digits = 0;
      0000B0 0F 05            [ 1]  198 	clr	(0x05, sp)
                                    199 ;	uart.c: 83: digits_buf[0] = '0';
      0000B2 AEr01r43         [ 2]  200 	ldw	x, #_digits_buf+0
      0000B5 1F 03            [ 2]  201 	ldw	(0x03, sp), x
      0000B7 1E 03            [ 2]  202 	ldw	x, (0x03, sp)
      0000B9 A6 30            [ 1]  203 	ld	a, #0x30
      0000BB F7               [ 1]  204 	ld	(x), a
                                    205 ;	uart.c: 85: for (i = 0; i < 6 && val != 0; i++) {
      0000BC 0F 02            [ 1]  206 	clr	(0x02, sp)
      0000BE                        207 00106$:
      0000BE 7B 02            [ 1]  208 	ld	a, (0x02, sp)
      0000C0 A1 06            [ 1]  209 	cp	a, #0x06
      0000C2 24 33            [ 1]  210 	jrnc	00103$
      0000C4 1E 08            [ 2]  211 	ldw	x, (0x08, sp)
      0000C6 A3 00 00         [ 2]  212 	cpw	x, #0x0000
      0000C9 27 2C            [ 1]  213 	jreq	00103$
                                    214 ;	uart.c: 86: uint8_t digit = val % 10;
      0000CB 1E 08            [ 2]  215 	ldw	x, (0x08, sp)
      0000CD 90 AE 00 0A      [ 2]  216 	ldw	y, #0x000a
      0000D1 65               [ 2]  217 	divw	x, y
      0000D2 61               [ 1]  218 	exg	a, yl
      0000D3 6B 01            [ 1]  219 	ld	(0x01, sp), a
      0000D5 61               [ 1]  220 	exg	a, yl
                                    221 ;	uart.c: 87: digits_buf[i] = '0' + digit;
      0000D6 5F               [ 1]  222 	clrw	x
      0000D7 7B 02            [ 1]  223 	ld	a, (0x02, sp)
      0000D9 97               [ 1]  224 	ld	xl, a
      0000DA 72 FB 03         [ 2]  225 	addw	x, (0x03, sp)
      0000DD 7B 01            [ 1]  226 	ld	a, (0x01, sp)
      0000DF AB 30            [ 1]  227 	add	a, #0x30
      0000E1 F7               [ 1]  228 	ld	(x), a
                                    229 ;	uart.c: 88: val /= 10;
      0000E2 1E 08            [ 2]  230 	ldw	x, (0x08, sp)
      0000E4 90 AE 00 0A      [ 2]  231 	ldw	y, #0x000a
      0000E8 65               [ 2]  232 	divw	x, y
      0000E9 1F 08            [ 2]  233 	ldw	(0x08, sp), x
                                    234 ;	uart.c: 89: if (digit) // We only really want to know about non-zero digits
      0000EB 0D 01            [ 1]  235 	tnz	(0x01, sp)
      0000ED 27 04            [ 1]  236 	jreq	00107$
                                    237 ;	uart.c: 90: num_digits = i;
      0000EF 7B 02            [ 1]  238 	ld	a, (0x02, sp)
      0000F1 6B 05            [ 1]  239 	ld	(0x05, sp), a
      0000F3                        240 00107$:
                                    241 ;	uart.c: 85: for (i = 0; i < 6 && val != 0; i++) {
      0000F3 0C 02            [ 1]  242 	inc	(0x02, sp)
      0000F5 20 C7            [ 2]  243 	jra	00106$
      0000F7                        244 00103$:
                                    245 ;	uart.c: 93: return num_digits + 1;
      0000F7 7B 05            [ 1]  246 	ld	a, (0x05, sp)
      0000F9 4C               [ 1]  247 	inc	a
      0000FA 5B 05            [ 2]  248 	addw	sp, #5
      0000FC 81               [ 4]  249 	ret
                                    250 ;	uart.c: 96: void uart_write_int(uint16_t val)
                                    251 ;	-----------------------------------------
                                    252 ;	 function uart_write_int
                                    253 ;	-----------------------------------------
      0000FD                        254 _uart_write_int:
      0000FD 52 03            [ 2]  255 	sub	sp, #3
                                    256 ;	uart.c: 101: highest_nonzero = int_to_digits(val);
      0000FF 1E 06            [ 2]  257 	ldw	x, (0x06, sp)
      000101 89               [ 2]  258 	pushw	x
      000102 CDr00rAE         [ 4]  259 	call	_int_to_digits
      000105 85               [ 2]  260 	popw	x
                                    261 ;	uart.c: 103: for (i = highest_nonzero-1; i >= 0; i--) {
      000106 4A               [ 1]  262 	dec	a
      000107 AEr01r43         [ 2]  263 	ldw	x, #_digits_buf+0
      00010A 1F 02            [ 2]  264 	ldw	(0x02, sp), x
      00010C 6B 01            [ 1]  265 	ld	(0x01, sp), a
      00010E                        266 00103$:
      00010E 0D 01            [ 1]  267 	tnz	(0x01, sp)
      000110 2B 11            [ 1]  268 	jrmi	00105$
                                    269 ;	uart.c: 104: uart_write_ch(digits_buf[i]);
      000112 5F               [ 1]  270 	clrw	x
      000113 7B 01            [ 1]  271 	ld	a, (0x01, sp)
      000115 97               [ 1]  272 	ld	xl, a
      000116 72 FB 02         [ 2]  273 	addw	x, (0x02, sp)
      000119 F6               [ 1]  274 	ld	a, (x)
      00011A 88               [ 1]  275 	push	a
      00011B CDr00r29         [ 4]  276 	call	_uart_write_ch
      00011E 84               [ 1]  277 	pop	a
                                    278 ;	uart.c: 103: for (i = highest_nonzero-1; i >= 0; i--) {
      00011F 0A 01            [ 1]  279 	dec	(0x01, sp)
      000121 20 EB            [ 2]  280 	jra	00103$
      000123                        281 00105$:
      000123 5B 03            [ 2]  282 	addw	sp, #3
      000125 81               [ 4]  283 	ret
                                    284 ;	uart.c: 108: static uint8_t int32_to_digits(uint32_t val)
                                    285 ;	-----------------------------------------
                                    286 ;	 function int32_to_digits
                                    287 ;	-----------------------------------------
      000126                        288 _int32_to_digits:
      000126 52 05            [ 2]  289 	sub	sp, #5
                                    290 ;	uart.c: 111: uint8_t num_digits = 0;
      000128 0F 03            [ 1]  291 	clr	(0x03, sp)
                                    292 ;	uart.c: 113: digits_buf[0] = '0';
      00012A AEr01r43         [ 2]  293 	ldw	x, #_digits_buf+0
      00012D 1F 04            [ 2]  294 	ldw	(0x04, sp), x
      00012F 1E 04            [ 2]  295 	ldw	x, (0x04, sp)
      000131 A6 30            [ 1]  296 	ld	a, #0x30
      000133 F7               [ 1]  297 	ld	(x), a
                                    298 ;	uart.c: 115: for (i = 0; i < 12 && val != 0; i++) {
      000134 0F 02            [ 1]  299 	clr	(0x02, sp)
      000136                        300 00106$:
      000136 7B 02            [ 1]  301 	ld	a, (0x02, sp)
      000138 A1 0C            [ 1]  302 	cp	a, #0x0c
      00013A 24 4F            [ 1]  303 	jrnc	00103$
      00013C 1E 0A            [ 2]  304 	ldw	x, (0x0a, sp)
      00013E A3 00 00         [ 2]  305 	cpw	x, #0x0000
      000141 26 07            [ 1]  306 	jrne	00129$
      000143 1E 08            [ 2]  307 	ldw	x, (0x08, sp)
      000145 A3 00 00         [ 2]  308 	cpw	x, #0x0000
      000148 27 41            [ 1]  309 	jreq	00103$
      00014A                        310 00129$:
                                    311 ;	uart.c: 116: uint8_t digit = val % 10;
      00014A 4B 0A            [ 1]  312 	push	#0x0a
      00014C 5F               [ 1]  313 	clrw	x
      00014D 89               [ 2]  314 	pushw	x
      00014E 4B 00            [ 1]  315 	push	#0x00
      000150 1E 0E            [ 2]  316 	ldw	x, (0x0e, sp)
      000152 89               [ 2]  317 	pushw	x
      000153 1E 0E            [ 2]  318 	ldw	x, (0x0e, sp)
      000155 89               [ 2]  319 	pushw	x
      000156 CDr00r00         [ 4]  320 	call	__modulong
      000159 5B 08            [ 2]  321 	addw	sp, #8
      00015B 9F               [ 1]  322 	ld	a, xl
      00015C 6B 01            [ 1]  323 	ld	(0x01, sp), a
                                    324 ;	uart.c: 117: digits_buf[i] = '0' + digit;
      00015E 5F               [ 1]  325 	clrw	x
      00015F 7B 02            [ 1]  326 	ld	a, (0x02, sp)
      000161 97               [ 1]  327 	ld	xl, a
      000162 72 FB 04         [ 2]  328 	addw	x, (0x04, sp)
      000165 7B 01            [ 1]  329 	ld	a, (0x01, sp)
      000167 AB 30            [ 1]  330 	add	a, #0x30
      000169 F7               [ 1]  331 	ld	(x), a
                                    332 ;	uart.c: 118: val /= 10;
      00016A 4B 0A            [ 1]  333 	push	#0x0a
      00016C 5F               [ 1]  334 	clrw	x
      00016D 89               [ 2]  335 	pushw	x
      00016E 4B 00            [ 1]  336 	push	#0x00
      000170 1E 0E            [ 2]  337 	ldw	x, (0x0e, sp)
      000172 89               [ 2]  338 	pushw	x
      000173 1E 0E            [ 2]  339 	ldw	x, (0x0e, sp)
      000175 89               [ 2]  340 	pushw	x
      000176 CDr00r00         [ 4]  341 	call	__divulong
      000179 5B 08            [ 2]  342 	addw	sp, #8
      00017B 1F 0A            [ 2]  343 	ldw	(0x0a, sp), x
      00017D 17 08            [ 2]  344 	ldw	(0x08, sp), y
                                    345 ;	uart.c: 119: if (digit) // We only really want to know about non-zero digits
      00017F 0D 01            [ 1]  346 	tnz	(0x01, sp)
      000181 27 04            [ 1]  347 	jreq	00107$
                                    348 ;	uart.c: 120: num_digits = i;
      000183 7B 02            [ 1]  349 	ld	a, (0x02, sp)
      000185 6B 03            [ 1]  350 	ld	(0x03, sp), a
      000187                        351 00107$:
                                    352 ;	uart.c: 115: for (i = 0; i < 12 && val != 0; i++) {
      000187 0C 02            [ 1]  353 	inc	(0x02, sp)
      000189 20 AB            [ 2]  354 	jra	00106$
      00018B                        355 00103$:
                                    356 ;	uart.c: 123: return num_digits + 1;
      00018B 7B 03            [ 1]  357 	ld	a, (0x03, sp)
      00018D 4C               [ 1]  358 	inc	a
      00018E 5B 05            [ 2]  359 	addw	sp, #5
      000190 81               [ 4]  360 	ret
                                    361 ;	uart.c: 126: void uart_write_int32(uint32_t val)
                                    362 ;	-----------------------------------------
                                    363 ;	 function uart_write_int32
                                    364 ;	-----------------------------------------
      000191                        365 _uart_write_int32:
      000191 52 03            [ 2]  366 	sub	sp, #3
                                    367 ;	uart.c: 131: highest_nonzero = int32_to_digits(val);
      000193 1E 08            [ 2]  368 	ldw	x, (0x08, sp)
      000195 89               [ 2]  369 	pushw	x
      000196 1E 08            [ 2]  370 	ldw	x, (0x08, sp)
      000198 89               [ 2]  371 	pushw	x
      000199 CDr01r26         [ 4]  372 	call	_int32_to_digits
      00019C 5B 04            [ 2]  373 	addw	sp, #4
                                    374 ;	uart.c: 133: for (i = highest_nonzero-1; i >= 0; i--) {
      00019E 4A               [ 1]  375 	dec	a
      00019F AEr01r43         [ 2]  376 	ldw	x, #_digits_buf+0
      0001A2 1F 02            [ 2]  377 	ldw	(0x02, sp), x
      0001A4 6B 01            [ 1]  378 	ld	(0x01, sp), a
      0001A6                        379 00103$:
      0001A6 0D 01            [ 1]  380 	tnz	(0x01, sp)
      0001A8 2B 11            [ 1]  381 	jrmi	00105$
                                    382 ;	uart.c: 134: uart_write_ch(digits_buf[i]);
      0001AA 5F               [ 1]  383 	clrw	x
      0001AB 7B 01            [ 1]  384 	ld	a, (0x01, sp)
      0001AD 97               [ 1]  385 	ld	xl, a
      0001AE 72 FB 02         [ 2]  386 	addw	x, (0x02, sp)
      0001B1 F6               [ 1]  387 	ld	a, (x)
      0001B2 88               [ 1]  388 	push	a
      0001B3 CDr00r29         [ 4]  389 	call	_uart_write_ch
      0001B6 84               [ 1]  390 	pop	a
                                    391 ;	uart.c: 133: for (i = highest_nonzero-1; i >= 0; i--) {
      0001B7 0A 01            [ 1]  392 	dec	(0x01, sp)
      0001B9 20 EB            [ 2]  393 	jra	00103$
      0001BB                        394 00105$:
      0001BB 5B 03            [ 2]  395 	addw	sp, #3
      0001BD 81               [ 4]  396 	ret
                                    397 ;	uart.c: 138: void uart_write_milliamp(uint16_t val)
                                    398 ;	-----------------------------------------
                                    399 ;	 function uart_write_milliamp
                                    400 ;	-----------------------------------------
      0001BE                        401 _uart_write_milliamp:
      0001BE 52 03            [ 2]  402 	sub	sp, #3
                                    403 ;	uart.c: 143: highest_nonzero = int_to_digits(val);
      0001C0 1E 06            [ 2]  404 	ldw	x, (0x06, sp)
      0001C2 89               [ 2]  405 	pushw	x
      0001C3 CDr00rAE         [ 4]  406 	call	_int_to_digits
      0001C6 85               [ 2]  407 	popw	x
                                    408 ;	uart.c: 145: for (i = highest_nonzero-1; i >= 0; i--) {
      0001C7 4A               [ 1]  409 	dec	a
      0001C8 AEr01r43         [ 2]  410 	ldw	x, #_digits_buf+0
      0001CB 1F 01            [ 2]  411 	ldw	(0x01, sp), x
      0001CD 6B 03            [ 1]  412 	ld	(0x03, sp), a
      0001CF                        413 00105$:
      0001CF 0D 03            [ 1]  414 	tnz	(0x03, sp)
      0001D1 2B 1D            [ 1]  415 	jrmi	00107$
                                    416 ;	uart.c: 146: if (i == 2)
      0001D3 7B 03            [ 1]  417 	ld	a, (0x03, sp)
      0001D5 A1 02            [ 1]  418 	cp	a, #0x02
      0001D7 26 06            [ 1]  419 	jrne	00102$
                                    420 ;	uart.c: 147: uart_write_ch('.');
      0001D9 4B 2E            [ 1]  421 	push	#0x2e
      0001DB CDr00r29         [ 4]  422 	call	_uart_write_ch
      0001DE 84               [ 1]  423 	pop	a
      0001DF                        424 00102$:
                                    425 ;	uart.c: 148: uart_write_ch(digits_buf[i]);
      0001DF 5F               [ 1]  426 	clrw	x
      0001E0 7B 03            [ 1]  427 	ld	a, (0x03, sp)
      0001E2 97               [ 1]  428 	ld	xl, a
      0001E3 72 FB 01         [ 2]  429 	addw	x, (0x01, sp)
      0001E6 F6               [ 1]  430 	ld	a, (x)
      0001E7 88               [ 1]  431 	push	a
      0001E8 CDr00r29         [ 4]  432 	call	_uart_write_ch
      0001EB 84               [ 1]  433 	pop	a
                                    434 ;	uart.c: 145: for (i = highest_nonzero-1; i >= 0; i--) {
      0001EC 0A 03            [ 1]  435 	dec	(0x03, sp)
      0001EE 20 DF            [ 2]  436 	jra	00105$
      0001F0                        437 00107$:
      0001F0 5B 03            [ 2]  438 	addw	sp, #3
      0001F2 81               [ 4]  439 	ret
                                    440 ;	uart.c: 152: void uart_write_millivolt(uint16_t val)
                                    441 ;	-----------------------------------------
                                    442 ;	 function uart_write_millivolt
                                    443 ;	-----------------------------------------
      0001F3                        444 _uart_write_millivolt:
      0001F3 52 03            [ 2]  445 	sub	sp, #3
                                    446 ;	uart.c: 157: highest_nonzero = int_to_digits(val);
      0001F5 1E 06            [ 2]  447 	ldw	x, (0x06, sp)
      0001F7 89               [ 2]  448 	pushw	x
      0001F8 CDr00rAE         [ 4]  449 	call	_int_to_digits
      0001FB 85               [ 2]  450 	popw	x
                                    451 ;	uart.c: 159: for (i = highest_nonzero-1; i >= 0; i--) {
      0001FC 4A               [ 1]  452 	dec	a
      0001FD AEr01r43         [ 2]  453 	ldw	x, #_digits_buf+0
      000200 1F 02            [ 2]  454 	ldw	(0x02, sp), x
      000202 6B 01            [ 1]  455 	ld	(0x01, sp), a
      000204                        456 00105$:
      000204 0D 01            [ 1]  457 	tnz	(0x01, sp)
      000206 2B 1D            [ 1]  458 	jrmi	00107$
                                    459 ;	uart.c: 160: if (i == 2)
      000208 7B 01            [ 1]  460 	ld	a, (0x01, sp)
      00020A A1 02            [ 1]  461 	cp	a, #0x02
      00020C 26 06            [ 1]  462 	jrne	00102$
                                    463 ;	uart.c: 161: uart_write_ch('.');
      00020E 4B 2E            [ 1]  464 	push	#0x2e
      000210 CDr00r29         [ 4]  465 	call	_uart_write_ch
      000213 84               [ 1]  466 	pop	a
      000214                        467 00102$:
                                    468 ;	uart.c: 162: uart_write_ch(digits_buf[i]);
      000214 5F               [ 1]  469 	clrw	x
      000215 7B 01            [ 1]  470 	ld	a, (0x01, sp)
      000217 97               [ 1]  471 	ld	xl, a
      000218 72 FB 02         [ 2]  472 	addw	x, (0x02, sp)
      00021B F6               [ 1]  473 	ld	a, (x)
      00021C 88               [ 1]  474 	push	a
      00021D CDr00r29         [ 4]  475 	call	_uart_write_ch
      000220 84               [ 1]  476 	pop	a
                                    477 ;	uart.c: 159: for (i = highest_nonzero-1; i >= 0; i--) {
      000221 0A 01            [ 1]  478 	dec	(0x01, sp)
      000223 20 DF            [ 2]  479 	jra	00105$
      000225                        480 00107$:
      000225 5B 03            [ 2]  481 	addw	sp, #3
      000227 81               [ 4]  482 	ret
                                    483 ;	uart.c: 166: void uart_write_fixed_point(uint32_t val)
                                    484 ;	-----------------------------------------
                                    485 ;	 function uart_write_fixed_point
                                    486 ;	-----------------------------------------
      000228                        487 _uart_write_fixed_point:
      000228 52 04            [ 2]  488 	sub	sp, #4
                                    489 ;	uart.c: 171: tmp = val >> FIXED_SHIFT;
      00022A 16 07            [ 2]  490 	ldw	y, (0x07, sp)
      00022C 5F               [ 1]  491 	clrw	x
                                    492 ;	uart.c: 172: uart_write_int(tmp);
      00022D 90 89            [ 2]  493 	pushw	y
      00022F CDr00rFD         [ 4]  494 	call	_uart_write_int
      000232 85               [ 2]  495 	popw	x
                                    496 ;	uart.c: 173: uart_write_ch('.');
      000233 4B 2E            [ 1]  497 	push	#0x2e
      000235 CDr00r29         [ 4]  498 	call	_uart_write_ch
      000238 84               [ 1]  499 	pop	a
                                    500 ;	uart.c: 176: tmp = val & FIXED_FRACTION_MASK;
      000239 16 09            [ 2]  501 	ldw	y, (0x09, sp)
      00023B 5F               [ 1]  502 	clrw	x
                                    503 ;	uart.c: 179: tmp = fixed_round(tmp*10000);
      00023C 90 89            [ 2]  504 	pushw	y
      00023E 89               [ 2]  505 	pushw	x
      00023F 4B 10            [ 1]  506 	push	#0x10
      000241 4B 27            [ 1]  507 	push	#0x27
      000243 5F               [ 1]  508 	clrw	x
      000244 89               [ 2]  509 	pushw	x
      000245 CDr00r00         [ 4]  510 	call	__mullong
      000248 5B 08            [ 2]  511 	addw	sp, #8
      00024A 89               [ 2]  512 	pushw	x
      00024B 90 89            [ 2]  513 	pushw	y
      00024D CDr00r00         [ 4]  514 	call	_fixed_round
      000250 5B 04            [ 2]  515 	addw	sp, #4
      000252 17 01            [ 2]  516 	ldw	(0x01, sp), y
                                    517 ;	uart.c: 182: if (tmp < 1000)
      000254 A3 03 E8         [ 2]  518 	cpw	x, #0x03e8
      000257 7B 02            [ 1]  519 	ld	a, (0x02, sp)
      000259 A2 00            [ 1]  520 	sbc	a, #0x00
      00025B 7B 01            [ 1]  521 	ld	a, (0x01, sp)
      00025D A2 00            [ 1]  522 	sbc	a, #0x00
      00025F 24 08            [ 1]  523 	jrnc	00102$
                                    524 ;	uart.c: 183: uart_write_ch('0');
      000261 89               [ 2]  525 	pushw	x
      000262 4B 30            [ 1]  526 	push	#0x30
      000264 CDr00r29         [ 4]  527 	call	_uart_write_ch
      000267 84               [ 1]  528 	pop	a
      000268 85               [ 2]  529 	popw	x
      000269                        530 00102$:
                                    531 ;	uart.c: 184: if (tmp < 100)
      000269 A3 00 64         [ 2]  532 	cpw	x, #0x0064
      00026C 7B 02            [ 1]  533 	ld	a, (0x02, sp)
      00026E A2 00            [ 1]  534 	sbc	a, #0x00
      000270 7B 01            [ 1]  535 	ld	a, (0x01, sp)
      000272 A2 00            [ 1]  536 	sbc	a, #0x00
      000274 24 08            [ 1]  537 	jrnc	00104$
                                    538 ;	uart.c: 185: uart_write_ch('0');
      000276 89               [ 2]  539 	pushw	x
      000277 4B 30            [ 1]  540 	push	#0x30
      000279 CDr00r29         [ 4]  541 	call	_uart_write_ch
      00027C 84               [ 1]  542 	pop	a
      00027D 85               [ 2]  543 	popw	x
      00027E                        544 00104$:
                                    545 ;	uart.c: 186: if (tmp < 10)
      00027E A3 00 0A         [ 2]  546 	cpw	x, #0x000a
      000281 7B 02            [ 1]  547 	ld	a, (0x02, sp)
      000283 A2 00            [ 1]  548 	sbc	a, #0x00
      000285 7B 01            [ 1]  549 	ld	a, (0x01, sp)
      000287 A2 00            [ 1]  550 	sbc	a, #0x00
      000289 24 08            [ 1]  551 	jrnc	00106$
                                    552 ;	uart.c: 187: uart_write_ch('0');
      00028B 89               [ 2]  553 	pushw	x
      00028C 4B 30            [ 1]  554 	push	#0x30
      00028E CDr00r29         [ 4]  555 	call	_uart_write_ch
      000291 84               [ 1]  556 	pop	a
      000292 85               [ 2]  557 	popw	x
      000293                        558 00106$:
                                    559 ;	uart.c: 190: uart_write_int32(tmp);
      000293 89               [ 2]  560 	pushw	x
      000294 1E 03            [ 2]  561 	ldw	x, (0x03, sp)
      000296 89               [ 2]  562 	pushw	x
      000297 CDr01r91         [ 4]  563 	call	_uart_write_int32
      00029A 5B 08            [ 2]  564 	addw	sp, #8
      00029C 81               [ 4]  565 	ret
                                    566 ;	uart.c: 193: void uart_write_from_buf(void)
                                    567 ;	-----------------------------------------
                                    568 ;	 function uart_write_from_buf
                                    569 ;	-----------------------------------------
      00029D                        570 _uart_write_from_buf:
                                    571 ;	uart.c: 195: USART1_DR = uart_write_buf[uart_write_start];
      00029D AEr00r00         [ 2]  572 	ldw	x, #_uart_write_buf+0
      0002A0 9F               [ 1]  573 	ld	a, xl
      0002A1 CBu00uFF         [ 1]  574 	add	a, _uart_write_start+0
      0002A4 02               [ 1]  575 	rlwa	x
      0002A5 A9 00            [ 1]  576 	adc	a, #0x00
      0002A7 95               [ 1]  577 	ld	xh, a
      0002A8 F6               [ 1]  578 	ld	a, (x)
      0002A9 AE 52 31         [ 2]  579 	ldw	x, #0x5231
      0002AC F7               [ 1]  580 	ld	(x), a
                                    581 ;	uart.c: 196: uart_write_start++;
      0002AD 72 5Cu00uFF      [ 1]  582 	inc	_uart_write_start+0
                                    583 ;	uart.c: 197: uart_write_len--;
      0002B1 72 5Au01u00      [ 1]  584 	dec	_uart_write_len+0
                                    585 ;	uart.c: 199: if (uart_write_len == 0)
      0002B5 72 5Du01u00      [ 1]  586 	tnz	_uart_write_len+0
      0002B9 26 04            [ 1]  587 	jrne	00103$
                                    588 ;	uart.c: 200: uart_write_start = 0;
      0002BB 72 5Fu00uFF      [ 1]  589 	clr	_uart_write_start+0
      0002BF                        590 00103$:
      0002BF 81               [ 4]  591 	ret
                                    592 ;	uart.c: 208: void uart_read_to_buf(void)
                                    593 ;	-----------------------------------------
                                    594 ;	 function uart_read_to_buf
                                    595 ;	-----------------------------------------
      0002C0                        596 _uart_read_to_buf:
                                    597 ;	uart.c: 211: uint8_t ch = uart_read_ch();
      0002C0 AE 52 31         [ 2]  598 	ldw	x, #0x5231
      0002C3 F6               [ 1]  599 	ld	a, (x)
      0002C4 90 95            [ 1]  600 	ld	yh, a
                                    601 ;	uart.c: 213: if (ch >= 'a' && ch <= 'z')
      0002C6 A1 61            [ 1]  602 	cp	a, #0x61
      0002C8 25 08            [ 1]  603 	jrc	00102$
      0002CA A1 7A            [ 1]  604 	cp	a, #0x7a
      0002CC 22 04            [ 1]  605 	jrugt	00102$
                                    606 ;	uart.c: 214: ch = ch - 'a' + 'A'; // Convert letters to uppercase
      0002CE AB E0            [ 1]  607 	add	a, #0xe0
      0002D0 90 95            [ 1]  608 	ld	yh, a
      0002D2                        609 00102$:
                                    610 ;	uart.c: 216: uart_read_buf[uart_read_len] = ch;
      0002D2 AEr01r01         [ 2]  611 	ldw	x, #_uart_read_buf+0
      0002D5 9F               [ 1]  612 	ld	a, xl
      0002D6 CBu01u41         [ 1]  613 	add	a, _uart_read_len+0
      0002D9 02               [ 1]  614 	rlwa	x
      0002DA A9 00            [ 1]  615 	adc	a, #0x00
      0002DC 95               [ 1]  616 	ld	xh, a
      0002DD 90 9E            [ 1]  617 	ld	a, yh
      0002DF F7               [ 1]  618 	ld	(x), a
                                    619 ;	uart.c: 217: uart_read_len++;
      0002E0 72 5Cu01u41      [ 1]  620 	inc	_uart_read_len+0
                                    621 ;	uart.c: 219: if (ch == '\r' || ch == '\n')
      0002E4 90 9E            [ 1]  622 	ld	a, yh
      0002E6 A1 0D            [ 1]  623 	cp	a, #0x0d
      0002E8 27 06            [ 1]  624 	jreq	00104$
      0002EA 90 9E            [ 1]  625 	ld	a, yh
      0002EC A1 0A            [ 1]  626 	cp	a, #0x0a
      0002EE 26 04            [ 1]  627 	jrne	00105$
      0002F0                        628 00104$:
                                    629 ;	uart.c: 220: read_newline = 1;
      0002F0 35 01u01u42      [ 1]  630 	mov	_read_newline+0, #0x01
      0002F4                        631 00105$:
                                    632 ;	uart.c: 223: if (uart_read_len == sizeof(uart_read_buf) && !read_newline) {
      0002F4 C6u01u41         [ 1]  633 	ld	a, _uart_read_len+0
      0002F7 A1 40            [ 1]  634 	cp	a, #0x40
      0002F9 26 12            [ 1]  635 	jrne	00111$
      0002FB 72 5Du01u42      [ 1]  636 	tnz	_read_newline+0
      0002FF 26 0C            [ 1]  637 	jrne	00111$
                                    638 ;	uart.c: 224: uart_read_len = 0;
      000301 72 5Fu01u41      [ 1]  639 	clr	_uart_read_len+0
                                    640 ;	uart.c: 225: uart_write_str("READ OVERFLOW\r\n");
      000305 AEr03r34         [ 2]  641 	ldw	x, #___str_0+0
      000308 89               [ 2]  642 	pushw	x
      000309 CDr00r48         [ 4]  643 	call	_uart_write_str
      00030C 85               [ 2]  644 	popw	x
      00030D                        645 00111$:
      00030D 81               [ 4]  646 	ret
                                    647 ;	uart.c: 229: void uart_drive(void)
                                    648 ;	-----------------------------------------
                                    649 ;	 function uart_drive
                                    650 ;	-----------------------------------------
      00030E                        651 _uart_drive:
                                    652 ;	uart.c: 231: uint8_t sr = USART1_SR;
      00030E AE 52 30         [ 2]  653 	ldw	x, #0x5230
      000311 F6               [ 1]  654 	ld	a, (x)
                                    655 ;	uart.c: 233: if (sr & USART_SR_RXNE) {
      000312 A5 20            [ 1]  656 	bcp	a, #0x20
      000314 27 05            [ 1]  657 	jreq	00102$
                                    658 ;	uart.c: 234: uart_read_to_buf();
      000316 88               [ 1]  659 	push	a
      000317 CDr02rC0         [ 4]  660 	call	_uart_read_to_buf
      00031A 84               [ 1]  661 	pop	a
      00031B                        662 00102$:
                                    663 ;	uart.c: 236: if ((sr & USART_SR_TXE) && uart_write_len) {
      00031B 4D               [ 1]  664 	tnz	a
      00031C 2A 09            [ 1]  665 	jrpl	00106$
      00031E 72 5Du01u00      [ 1]  666 	tnz	_uart_write_len+0
      000322 27 03            [ 1]  667 	jreq	00106$
                                    668 ;	uart.c: 237: uart_write_from_buf();
      000324 CDr02r9D         [ 4]  669 	call	_uart_write_from_buf
      000327                        670 00106$:
      000327 81               [ 4]  671 	ret
                                    672 ;	uart.c: 241: void uart_flush_writes(void)
                                    673 ;	-----------------------------------------
                                    674 ;	 function uart_flush_writes
                                    675 ;	-----------------------------------------
      000328                        676 _uart_flush_writes:
                                    677 ;	uart.c: 243: while (uart_write_len > 0)
      000328                        678 00101$:
      000328 72 5Du01u00      [ 1]  679 	tnz	_uart_write_len+0
      00032C 27 05            [ 1]  680 	jreq	00104$
                                    681 ;	uart.c: 244: uart_drive();
      00032E CDr03r0E         [ 4]  682 	call	_uart_drive
      000331 20 F5            [ 2]  683 	jra	00101$
      000333                        684 00104$:
      000333 81               [ 4]  685 	ret
                                    686 	.area CODE
      000334                        687 ___str_0:
      000334 52 45 41 44 20 4F 56   688 	.ascii "READ OVERFLOW"
             45 52 46 4C 4F 57
      000341 0D                     689 	.db 0x0D
      000342 0A                     690 	.db 0x0A
      000343 00                     691 	.db 0x00
                                    692 	.area INITIALIZER
                                    693 	.area CABS (ABS)
